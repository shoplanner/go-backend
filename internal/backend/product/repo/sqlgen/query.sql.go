// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sqlgen

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const deleteFormsByProductID = `-- name: DeleteFormsByProductID :exec
DELETE FROM
    product_forms
WHERE
    product_id = ?
`

func (q *Queries) DeleteFormsByProductID(ctx context.Context, productID string) error {
	_, err := q.db.ExecContext(ctx, deleteFormsByProductID, productID)
	return err
}

const deleteProductByID = `-- name: DeleteProductByID :exec
DELETE FROM
    products
WHERE
    id = ?
`

func (q *Queries) DeleteProductByID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProductByID, id)
	return err
}

const getFormsByProductID = `-- name: GetFormsByProductID :many
SELECT
    id,
    product_id,
    name
FROM
    product_forms
WHERE
    product_id = ?
`

func (q *Queries) GetFormsByProductID(ctx context.Context, productID string) ([]ProductForm, error) {
	rows, err := q.db.QueryContext(ctx, getFormsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductForm
	for rows.Next() {
		var i ProductForm
		if err := rows.Scan(&i.ID, &i.ProductID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormsByProductListID = `-- name: GetFormsByProductListID :many
SELECT
    id,
    product_id,
    name
FROM
    product_forms
WHERE
    product_id IN (/*SLICE:product_ids*/?)
`

func (q *Queries) GetFormsByProductListID(ctx context.Context, productIds []string) ([]ProductForm, error) {
	query := getFormsByProductListID
	var queryParams []interface{}
	if len(productIds) > 0 {
		for _, v := range productIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_ids*/?", strings.Repeat(",?", len(productIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductForm
	for rows.Next() {
		var i ProductForm
		if err := rows.Scan(&i.ID, &i.ProductID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    p.id,
    p.created_at,
    p.updated_at,
    p.name,
    p.category_id,
    pc.name AS category_name
FROM
    products p
    LEFT JOIN product_categories pc ON p.category_id = pc.id OR p.category_id = pc.name
WHERE
    p.id = ?
LIMIT
    1
`

type GetProductByIDRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Name         string
	CategoryID   sql.NullString
	CategoryName sql.NullString
}

func (q *Queries) GetProductByID(ctx context.Context, id string) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.CategoryID,
		&i.CategoryName,
	)
	return i, err
}

const getProductsByListID = `-- name: GetProductsByListID :many
SELECT
    p.id,
    p.created_at,
    p.updated_at,
    p.name,
    p.category_id,
    pc.name AS category_name
FROM
    products p
    LEFT JOIN product_categories pc ON p.category_id = pc.id OR p.category_id = pc.name
WHERE
    p.id IN (/*SLICE:product_ids*/?)
`

type GetProductsByListIDRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Name         string
	CategoryID   sql.NullString
	CategoryName sql.NullString
}

func (q *Queries) GetProductsByListID(ctx context.Context, productIds []string) ([]GetProductsByListIDRow, error) {
	query := getProductsByListID
	var queryParams []interface{}
	if len(productIds) > 0 {
		for _, v := range productIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_ids*/?", strings.Repeat(",?", len(productIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByListIDRow
	for rows.Next() {
		var i GetProductsByListIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.CategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertProductForm = `-- name: InsertProductForm :exec
INSERT INTO
    product_forms(id, product_id, name)
VALUES
    (?, ?, ?)
`

type InsertProductFormParams struct {
	ID        string
	ProductID string
	Name      string
}

func (q *Queries) InsertProductForm(ctx context.Context, arg InsertProductFormParams) error {
	_, err := q.db.ExecContext(ctx, insertProductForm, arg.ID, arg.ProductID, arg.Name)
	return err
}

const upsertCategory = `-- name: UpsertCategory :exec
INSERT INTO
    product_categories(id, name)
VALUES
    (?, ?)
ON DUPLICATE KEY UPDATE
    name = VALUES(name)
`

type UpsertCategoryParams struct {
	ID   string
	Name string
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) error {
	_, err := q.db.ExecContext(ctx, upsertCategory, arg.ID, arg.Name)
	return err
}

const upsertProduct = `-- name: UpsertProduct :exec
INSERT INTO
    products(id, created_at, updated_at, name, category_id)
VALUES
    (?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    created_at = VALUES(created_at),
    updated_at = VALUES(updated_at),
    name = VALUES(name),
    category_id = VALUES(category_id)
`

type UpsertProductParams struct {
	ID         string
	CreatedAt  time.Time
	UpdatedAt  time.Time
	Name       string
	CategoryID sql.NullString
}

func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) error {
	_, err := q.db.ExecContext(ctx, upsertProduct,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.CategoryID,
	)
	return err
}
