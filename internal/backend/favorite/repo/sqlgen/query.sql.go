// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sqlgen

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const createFavoriteList = `-- name: CreateFavoriteList :exec
INSERT INTO
    favorite_lists(id, list_type, created_at, updated_at)
VALUES
    (?, ?, ?, ?)
`

type CreateFavoriteListParams struct {
	ID        string
	ListType  int32
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateFavoriteList(ctx context.Context, arg CreateFavoriteListParams) error {
	_, err := q.db.ExecContext(ctx, createFavoriteList,
		arg.ID,
		arg.ListType,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createFavoriteMember = `-- name: CreateFavoriteMember :exec
INSERT INTO
    favorite_members(id, user_id, favorite_list_id, created_at, updated_at, member_type)
VALUES
    (?, ?, ?, ?, ?, ?)
`

type CreateFavoriteMemberParams struct {
	ID             string
	UserID         string
	FavoriteListID string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	MemberType     int32
}

func (q *Queries) CreateFavoriteMember(ctx context.Context, arg CreateFavoriteMemberParams) error {
	_, err := q.db.ExecContext(ctx, createFavoriteMember,
		arg.ID,
		arg.UserID,
		arg.FavoriteListID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.MemberType,
	)
	return err
}

const createFavoriteProduct = `-- name: CreateFavoriteProduct :exec
INSERT INTO
    favorite_products(id, product_id, favorite_list_id, created_at, updated_at)
VALUES
    (?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    updated_at = VALUES(updated_at)
`

type CreateFavoriteProductParams struct {
	ID             string
	ProductID      string
	FavoriteListID string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) CreateFavoriteProduct(ctx context.Context, arg CreateFavoriteProductParams) error {
	_, err := q.db.ExecContext(ctx, createFavoriteProduct,
		arg.ID,
		arg.ProductID,
		arg.FavoriteListID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteFavoriteList = `-- name: DeleteFavoriteList :exec
DELETE FROM
    favorite_lists
WHERE
    id = ?
`

func (q *Queries) DeleteFavoriteList(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFavoriteList, id)
	return err
}

const deleteFavoriteMembersByListID = `-- name: DeleteFavoriteMembersByListID :exec
DELETE FROM
    favorite_members
WHERE
    favorite_list_id = ?
`

func (q *Queries) DeleteFavoriteMembersByListID(ctx context.Context, favoriteListID string) error {
	_, err := q.db.ExecContext(ctx, deleteFavoriteMembersByListID, favoriteListID)
	return err
}

const deleteFavoriteProductsByListID = `-- name: DeleteFavoriteProductsByListID :exec
DELETE FROM
    favorite_products
WHERE
    favorite_list_id = ?
`

func (q *Queries) DeleteFavoriteProductsByListID(ctx context.Context, favoriteListID string) error {
	_, err := q.db.ExecContext(ctx, deleteFavoriteProductsByListID, favoriteListID)
	return err
}

const getFavoriteListByID = `-- name: GetFavoriteListByID :one
SELECT
    id,
    list_type,
    created_at,
    updated_at
FROM
    favorite_lists
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetFavoriteListByID(ctx context.Context, id string) (FavoriteList, error) {
	row := q.db.QueryRowContext(ctx, getFavoriteListByID, id)
	var i FavoriteList
	err := row.Scan(
		&i.ID,
		&i.ListType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFavoriteListIDsByUserID = `-- name: GetFavoriteListIDsByUserID :many
SELECT DISTINCT
    fl.id
FROM
    favorite_lists fl
    JOIN favorite_members fm ON fm.favorite_list_id = fl.id
WHERE
    fm.user_id = ?
`

func (q *Queries) GetFavoriteListIDsByUserID(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getFavoriteListIDsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavoriteMembersByListID = `-- name: GetFavoriteMembersByListID :many
SELECT
    user_id,
    member_type,
    created_at,
    updated_at
FROM
    favorite_members
WHERE
    favorite_list_id = ?
`

type GetFavoriteMembersByListIDRow struct {
	UserID     string
	MemberType int32
	CreatedAt  time.Time
	UpdatedAt  time.Time
}

func (q *Queries) GetFavoriteMembersByListID(ctx context.Context, favoriteListID string) ([]GetFavoriteMembersByListIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getFavoriteMembersByListID, favoriteListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavoriteMembersByListIDRow
	for rows.Next() {
		var i GetFavoriteMembersByListIDRow
		if err := rows.Scan(
			&i.UserID,
			&i.MemberType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFavoriteProductsByListID = `-- name: GetFavoriteProductsByListID :many
SELECT
    product_id,
    created_at,
    updated_at
FROM
    favorite_products
WHERE
    favorite_list_id = ?
`

type GetFavoriteProductsByListIDRow struct {
	ProductID string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) GetFavoriteProductsByListID(ctx context.Context, favoriteListID string) ([]GetFavoriteProductsByListIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getFavoriteProductsByListID, favoriteListID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFavoriteProductsByListIDRow
	for rows.Next() {
		var i GetFavoriteProductsByListIDRow
		if err := rows.Scan(&i.ProductID, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadProductsByIDs = `-- name: LoadProductsByIDs :many
SELECT
    p.id,
    p.created_at,
    p.updated_at,
    p.name,
    p.category_id,
    pc.name AS category_name,
    pf.id AS form_id,
    pf.name AS form_name
FROM
    products p
    LEFT JOIN product_categories pc ON p.category_id = pc.id OR p.category_id = pc.name
    LEFT JOIN product_forms pf ON pf.product_id = p.id
WHERE
    p.id IN (/*SLICE:product_ids*/?)
ORDER BY
    p.id
`

type LoadProductsByIDsRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Name         string
	CategoryID   sql.NullString
	CategoryName sql.NullString
	FormID       sql.NullString
	FormName     sql.NullString
}

func (q *Queries) LoadProductsByIDs(ctx context.Context, productIds []string) ([]LoadProductsByIDsRow, error) {
	query := loadProductsByIDs
	var queryParams []interface{}
	if len(productIds) > 0 {
		for _, v := range productIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:product_ids*/?", strings.Repeat(",?", len(productIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:product_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadProductsByIDsRow
	for rows.Next() {
		var i LoadProductsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.CategoryID,
			&i.CategoryName,
			&i.FormID,
			&i.FormName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFavoriteList = `-- name: UpdateFavoriteList :exec
UPDATE favorite_lists
SET
    list_type = ?,
    created_at = ?,
    updated_at = ?
WHERE
    id = ?
`

type UpdateFavoriteListParams struct {
	ListType  int32
	CreatedAt time.Time
	UpdatedAt time.Time
	ID        string
}

func (q *Queries) UpdateFavoriteList(ctx context.Context, arg UpdateFavoriteListParams) error {
	_, err := q.db.ExecContext(ctx, updateFavoriteList,
		arg.ListType,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
